pjrpc - Painless-JSON-RPC
========

Golang JSON-RPC router with code and specs generator (Swagger included).

# Features

- **Lightweight** - simple and fast router
- **Dependency free** - it's requried uuid package in generated code only
- **JSON-RPC protocol** - support protocol [v2.0](https://www.jsonrpc.org/specification) + Batch requests
- **Go std-lib compatible** - net/http, json.RawMessage
- **Go way context usage** - ctx in your handlers with data
- **Handler middlewares** - use your repeatable code as middlewares
- **Boilerplate code generator** - unmarshalling JSON params to custom models
- **Go spec** - describe your types and methods in Go with [genpjrpc](https://gitlab.com/pjrpc/pjrpc/-/tree/master/cmd/genpjrpc) generator
- **Swagger spec** - genpjrpc can generate openapi spec with methods and types based on Go code.
- **WASM Client** - JSON-RPC client with generated files can compile to [WASM](https://gitlab.com/pjrpc/pjrpc/-/tree/master/_examples/wasm)
- **Using as JSON-RPC router** - you can use this router like a simple JSON-RPC router [without code-gen](https://gitlab.com/pjrpc/pjrpc/-/tree/master/_examples/without-code-gen)

[Benchmarks](https://gitlab.com/pjrpc/benchmarks)


# Golang as a spec

Create your Go types as transport models and use them in the service interface.

See documentation of the [genpjrpc](https://gitlab.com/pjrpc/pjrpc/-/tree/master/cmd/genpjrpc) for details.

file `model/types/types.go`:

```go
package types

type Request struct {
	Name string `json:"name"`
}

type Response struct {
	ID int `json:"id"`
}
```

file `model/service/service.go`:

```go
package serivce

import "app/model/types"

// Service description...
//go:generate genpjrpc -search.name=Service -print.place.path_swagger_file=../../api/swagger.json
type Service interface {
	Method(types.Request) types.Response
}
```

## Install

```sh
go install gitlab.com/pjrpc/pjrpc/cmd/genpjrpc@latest
```

## Run generator:

```
go generate ./...
```

Files will be generated by genpjrpc:

```
# Go wrappers for server register func and real server interface.
./app/model/service/rpcserver/pjrpc_server_service.go

# Go wrappers for client to the rpc serice.
./app/model/service/rpcclient/pjrpc_client_service.go

# OpenAPI spec with rpc methods and every used type.
./app/api/swagger.json
```

# Examples

- [pkg.go.dev](https://pkg.go.dev/gitlab.com/pjrpc/pjrpc)
- [Hello world](https://gitlab.com/pjrpc/pjrpc/-/tree/master/_examples/helloworld)
- [Middlewares + Client mods](https://gitlab.com/pjrpc/pjrpc/-/tree/master/_examples/middlewares)
- [WASM](https://gitlab.com/pjrpc/pjrpc/-/tree/master/_examples/wasm)
- [Without code gen](https://gitlab.com/pjrpc/pjrpc/-/tree/master/_examples/without-code-gen)


## Server example

```go
package main

import (
	"context"
	"errors"
	"log"
	"net/http"

	"gitlab.com/pjrpc/pjrpc/v2"

	"app/model/service/rpcserver"
	"app/model/types"
)

var errServer = errors.New("server error")

type rpc struct{}

// Method responder.
func (r *rpc) Method(ctx context.Context, in *types.Request) (*types.Response, error) {
	log.Printf("got message from: %s", in.Name)

	switch in.Name {
	case "rpc client": // it's ok, pass

	case "error": // return golang error
		return nil, errServer

	case "panic":
		panic("rpc client sent panic")

	default: // returns json-rpc error
		return nil, jerrs.InvalidParams("wrong name")
	}

	return &types.Response{Name: "rpc server"}, nil
}

func main() {
	srv := pjrpc.NewServerHTTP()
	srv.SetLogger(log.Writer())

	r := &rpc{}

	rpcserver.RegisterServiceServer(srv, r)

	mux := http.NewServeMux()
	mux.Handle("/rpc/", srv)

	log.Println("Starting rpc server on :8080")

	err := http.ListenAndServe(":8080", mux)
	if err != nil {
		log.Fatalf("http.ListenAndServe: %s", err)
	}
}
```

**request:**

```json
{
  "jsonrpc": "2.0",
  "id": "1",
  "method": "hello",
  "params": {
    "name": "rpc client"
  }
}
```

**response:**
```json
{
  "jsonrpc": "2.0",
  "id": "1",
  "result": {
    "name": "rpc server"
  }
}
```
